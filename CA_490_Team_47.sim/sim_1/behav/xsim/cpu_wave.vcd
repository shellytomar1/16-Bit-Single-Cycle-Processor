$date
   Sat Mar 29 03:07:18 2025
$end

$version
  2024.2.0
  $dumpfile ("cpu_wave.vcd") 
$end

$timescale
  1ps
$end

$scope module CPU_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$var wire 16 # pc_out [15:0] $end
$scope module uut $end
$var wire 1 $ clk $end
$var wire 1 % rst $end
$var wire 16 # pc_out [15:0] $end
$var wire 16 & instruction [15:0] $end
$var wire 4 ' opcode [3:0] $end
$var wire 4 ( rs [3:0] $end
$var wire 4 ) rt [3:0] $end
$var wire 4 * rd [3:0] $end
$var wire 16 + data_rs [15:0] $end
$var wire 16 , data_rt [15:0] $end
$var wire 16 - ALU_result [15:0] $end
$var wire 16 . mem_out [15:0] $end
$var wire 16 / sign_extended_imm [15:0] $end
$var wire 16 0 reg_write_data [15:0] $end
$var wire 1 1 reg_write $end
$var wire 1 2 mem_read $end
$var wire 1 3 mem_write $end
$var wire 1 4 byte_enable $end
$var wire 1 5 mux_sel $end
$var wire 4 6 ALU_op [3:0] $end
$scope module PC $end
$var wire 1 $ clk $end
$var wire 1 % rst $end
$var wire 1 7 inc $end
$var wire 16 - new_address [15:0] $end
$var reg 16 8 pc_out [15:0] $end
$upscope $end
$scope module IM $end
$var wire 16 # address [15:0] $end
$var reg 16 9 instruction [15:0] $end
$upscope $end
$scope module CU $end
$var wire 16 & instruction [15:0] $end
$var reg 4 : ALU_op [3:0] $end
$var reg 1 ; reg_write $end
$var reg 1 < mem_read $end
$var reg 1 = mem_write $end
$var reg 1 > mux_sel $end
$var reg 1 ? byte_enable $end
$upscope $end
$scope module RF $end
$var wire 1 $ clk $end
$var wire 1 % rst $end
$var wire 1 1 reg_write $end
$var wire 4 ( rs [3:0] $end
$var wire 4 ) rt [3:0] $end
$var wire 4 * rd [3:0] $end
$var wire 16 0 data_in [15:0] $end
$var reg 16 @ data_rs [15:0] $end
$var reg 16 A data_rt [15:0] $end
$upscope $end
$scope module SE $end
$var wire 4 ) in [3:0] $end
$var reg 16 B out [15:0] $end
$upscope $end
$scope module alu $end
$var wire 16 + A [15:0] $end
$var wire 16 / B [15:0] $end
$var wire 4 6 ALU_op [3:0] $end
$var reg 16 C Result [15:0] $end
$upscope $end
$scope module DM $end
$var wire 1 $ clk $end
$var wire 1 2 mem_read $end
$var wire 1 3 mem_write $end
$var wire 1 4 byte_enable $end
$var wire 16 - address [15:0] $end
$var wire 16 , data_in [15:0] $end
$var reg 16 D data_out [15:0] $end
$upscope $end
$scope module MUX $end
$var wire 16 - in0 [15:0] $end
$var wire 16 . in1 [15:0] $end
$var wire 1 5 sel $end
$var reg 16 E out [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end

#0
$dumpvars
0!
1"
b0 #
0$
1%
b100000100000100 &
b100 '
b0 (
bz )
b1 *
bx +
bx ,
bx -
bx .
bx /
bx 0
01
02
03
04
05
b1 6
17
b0 8
b100000100000100 9
b1 :
0;
0<
0=
0>
0?
bx @
bx A
bx B
bx C
bx D
bx E
$end

#5000
1!
1$

#10000
0!
0"
0$
0%

#15000
1!
b10 #
1$
b1001000000000 &
b1 '
b10 *
11
12
15
b0 6
b10 8
b1001000000000 9
b0 :
1;
1<
1>

#20000
0!
0$

#25000
1!
b100 #
1$
b1100100010 &
b0 '
b10 (
b11 *
02
05
b10 6
b100 8
b1100100010 9
b10 :
0<
0>

#30000
0!
0$

#35000
1!
b110 #
1$
b10001100010010 &
b10 '
b1 (
b0 +
01
13
b0 6
b110 8
b10001100010010 9
b0 :
0;
1=
b0 @

#40000
0!
0$

#45000
1!
b1000 #
1$
bx &
bx '
bx (
bx *
bx +
03
b1000 8
bx 9
0=
bx @

#50000
0!
0$

#55000
1!
b1010 #
1$
b1010 8

#60000
0!
0$

#65000
1!
b1100 #
1$
b1100 8

#70000
0!
0$

#75000
1!
b1110 #
1$
b1110 8

#80000
0!
0$

#85000
1!
b10000 #
1$
b10000 8

#90000
0!
0$

#95000
1!
b10010 #
1$
b10010 8

#100000
0!
0$

#105000
1!
b10100 #
1$
b10100 8
